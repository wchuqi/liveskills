# 算法思想

培养算法的框架思维，算法结构化、模板化

从整体到细节，⾃顶向下，从抽象到具体的框架思维是通⽤的。不只是学习数据结构和算法，学习其他任何知识都是⾼效的。

# 数据结构

**数据结构是⼯具，算法是通过合适的⼯具解决特定问题的⽅法。**

## 数据结构的存储⽅式
数据结构的存储⽅式只有两种：
1、数组（顺序存储）
2、链表（链式存储）

数组和链表是`结构基础`，散列表、栈、队列、堆、树、图等等各种数据结构，究其源头，都是在链表或者数组上的特殊操作，只是API不同⽽已。

**队列、栈**
既可以使⽤链表，也可以使⽤数组实现。
⽤数组实现，就要处理扩容缩容的问题；⽤链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

**图**
有两种表⽰⽅法，邻接表就是链表，邻接矩阵就是⼆维数组。
邻接矩阵判断连通性迅速，并可以进⾏矩阵运算解决⼀些问题，但是如果图⽐较稀疏的话很耗费空间。邻接表⽐较节省空间，但是很多操作的效率上肯定⽐过邻接矩阵。

**散列表**
通过散列函数把键映射到⼀个⼤数组⾥。
对于解决散列冲突的⽅法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

**树**
⽤数组实现就是**堆**，因为**堆**是⼀个完全⼆叉树，⽤数组存储不需要节点指针，操作也⽐较简单；
⽤链表实现就是很常⻅的那种**树**，因为不⼀定是完全⼆叉树，所以不适合⽤数组存储。
为此，在这种**链表树**结构之上，⼜衍⽣出各种巧妙的设计，⽐如⼆叉搜索树、AVL树、红⿊树、区间树、B 树等等，以应对不同的问题。

Redis 提供列表、字符串、集合等等⼏种常⽤数据结构。但是对于每种数据结构，底层的存储⽅式都⾄少有两种，以便于根据存储数据的实际情况使⽤合适的存储⽅式。

**总结：**
1、数组
由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，⽽且相对节约存储空间。
但正因为连续存储，内存空间必须⼀次性分配够。
所以说数组如果要扩容，需要重新分配⼀块更⼤的空间，再把数据全部复制过去，时间复杂度 O(N)；⽽且你如果想在数组中间进⾏插⼊和删除，每次必须搬移后⾯的所有数据以保持连续，时间复杂度 O(N)。
2、链表
因为元素不连续，⽽是靠指针指向下⼀个元素的位置，所以不存在数组的扩容问题；如果知道某⼀元素的前驱和后驱，操作指针即可删除该元素或者插⼊新元素，时间复杂度 O(1)。
但是正因为存储空间不连续，⽆法根据⼀个索引算出对应元素的地址，所以不能随机访问；⽽且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

## 数据结构的基本操作
对于任何数据结构，其基本操作⽆⾮**遍历 + 访问**，再具体⼀点就是：增删查改。

数据结构种类很多，但它们存在的⽬的都是在不同的应⽤场景，尽可能⾼效地增删查改。

如何遍历 + 访问？
从最⾼层来看，各种数据结构的遍历 + 访问⽆⾮两种形式：线性的和⾮线性的。

**线性**就是`for/while`迭代为代表，**⾮线性**就是`递归`为代表。

**参考算法框架**


# 算法框架

所谓框架，就是套路。
不管增删查改，这些代码都是永远⽆法脱离的结构，可以把这个结构作为⼤纲，根据具体问题在框架上添加代码就⾏了。


总结为以下框架：
1、数组遍历框架，典型的线性迭代结构
```java
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        // 迭代访问 arr[i]
    }
}
```
2、链表遍历框架，兼具迭代和递归结构
```java
/* 基本的单链表节点 */
class ListNode {
    int val;
    ListNode next;
}
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {
        // 迭代访问 p.val
    }
}
void traverse(ListNode head) {
    // 递归访问 head.val
    traverse(head.next)
}
```

⼆叉树遍历框架，典型的⾮线性递归遍历结构
```java
/* 基本的⼆叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}
```

N叉树的遍历框架
```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
void traverse(TreeNode root) {
    for (TreeNode child : root.children) {
       traverse(child)
    }
}
```

N叉树的遍历⼜可以扩展为图的遍历，因为图就是好⼏个N叉棵树的结合体。

# 二叉树

## 124. 二叉树中的最大路径和
https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/
二叉树中的 路径 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。

题解：
对于树的题目，有统一的思考方法，那就是**站在树（子树）的顶端根节点root思考。**

那么对于此题，我们思考如下问题：**如果当前处在root节点，左右节点应该告诉我们什么信息才能得到答案？**

根据题中对路径的定义，对于此题我们来回答以上问题。当我们遍历到树中某个节点时，**我希望左子节点告诉我，在左子树中，以左子节点为开始（端点）的路径和最大为多少，同理我也希望右子节点告诉我类似的信息。**

如果有了以上信息，再来思考最后一个问题：**有了这个信息如何得到答案？**

显然，对于当前节点有四个选择：
1、我自己就是一条路径
2、只跟左子节点合并成一条路径
3、只跟右子节点合并成一条路径
4、以自己为桥梁，跟左、右子节点合并成一条路径

需要注意的是，我们**在递归求解的时候，第四种情况是不能作为递归的返回值的**，因为它不符合我们对递归所期望返回值的定义（因为此时该子节点并不是拥有最大路径和路径的起点（端点）），但它也是一个可能的解，所以我们用一个全局变量记录上面四种值的最大值，递归结束后，该变量就是答案。

再次强调一下，当节点以自己为桥梁连接两边形成一条路径时，根据路径定义，其祖先节点不再可能加入到这条路径中，也就是说这种情况下，它是解的一种可能，但不符合我们递归返回值的定义。

想通上面的逻辑后，代码就呼之欲出了，看看最后的代码，核心的就六七行，却解决了一个Hard问题。

作者：vanilla111
链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/962707/javadi-gui-zi-ding-xiang-xia-bang-zhu-ji-8bmv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    int pathSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return pathSum;
    }

    // dfs 返回以该节点为端点的最大路径和
    public int dfs(TreeNode node) {
        if (node == null) return 0;
        int left = dfs(node.left);
        int right = dfs(node.right);
        // 当前节点有四个选择：
        // 1）独立成线，直接返回自己的值 
        // 2）跟左子节点合成一条路径 
        // 3）跟右子节点合成一条路径
        int ret = Math.max(node.val, node.val + Math.max(left, right));
        // 4）以自己为桥梁，跟左、右子节点合并成一条路径
        pathSum = Math.max(pathSum, Math.max(ret, node.val + left + right));
        return ret;
    }
}
```

# 动态规划

# 回溯

# 二分查找

# 滑动窗口

# 双指针

# BFS


